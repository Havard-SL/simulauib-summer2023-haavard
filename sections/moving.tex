\subsection{Improvements}

\begin{idea} \label{idea:improved-construction}
    The current construction as defined in \autoref{construction:affine-automorphism-quasigroup} is limited in that one can only say that for any \( \phi \in \Sym(n) \) there is a \( \tilde{Q} \) with left identity or a \( \tilde{Q} \) that is commutative such that \( \phi \in \AAut(\tilde{Q}) \). One can not have both at the same time due to \autoref{remark:left-identity-killed}.

    However, the current construction is limited to looking for affine automorphisms on the form \( \phi(x) = \Id(x) *_{\tilde{Q}} a \) for some \( a \in \tilde{Q} \). If it could be extended to find affine automorphisms on the form \( \phi(x) = \alpha(x) *_{\tilde{Q}} a \) for some \( \alpha \in \Aut(\tilde{Q}) \), then that would be a big improvement and could possibly avoid the consequences mentioned in \autoref{remark:left-identity-killed}.

    As a summary, here is the current limitations that have been found:

    For \( n = 5 \), for any \( \phi = (3, 4) \), it is \emph{not possible} to find a \( \tilde{Q} \) that is a group or better, such that \( \phi \in \AAut(\tilde{Q}) \), by \autoref{counterexample:ab-aaut}.

    For any \( n \), for any \( \phi \in \Sym(n) \), \emph{using the current construction}, it is \emph{not possible} to find any \( \tilde{Q} \) that is a loop or better, such that \( \phi \in \AAut(\tilde{Q}) \), by \autoref{remark:left-identity-killed}.

    Therefore I conjecture these two statements:

    Firstly, a new and improved construction \emph{could} for any \( n \), for any \( \phi \in \Sym(n) \), find a \( \tilde{Q} \) that is at least a loop, such that \( \phi \in \AAut(\tilde{Q}) \).

    Secondly, a new and improved constrocution \emph{could} for \emph{certain} \( n \), for any (or most likely, only \emph{certain}) \( \phi \in \Sym(n) \), find a \( \tilde{Q} \) that is an abelian group, such that \( \phi \in \AAut(\tilde{Q}) \).
\end{idea}

\begin{idea}
    \autoref{remark:ab-aaut-counterexample-notes}.
\end{idea}

\begin{idea} \label{idea:code-improvements}
    The code can currently only generate up to \( 5 \times 5 \) latin squares. If one tries to generate \( 6 \times 6 \) latin squares it doesn't work. In order to improve the generation algorithm I have the following two ideas:
    
    Firstly, reduce the amount of latin squares that is needed to be generated:

    By finding a certain ``class'' of latin squares that can be used to test and classify a result, one would only need to generate those in order to test the result. For finding a quasigroup where a permutation is an affine automorphism, perhaps only one of the representatives with a certain affine fingerprint (\autoref{idea:fingerprints}) need to be generated. How to do that efficiently, I do not know. 
    
    % TODO: Maybe rewrite
    This could further be whittled down if one for example knew that there always was a loop where a map was an affine automorphism, so one only needed to generate all the loops with different fingerprint, etc... Or maybe one only needed to generate every abelian group and then permute the rows/columns/elements in a certain way to get the rest (permuting rows/columns/elements is applying an isotopy).
    
    Best case scenario is one only has to generate some of the abelian groups with fixed identity, and then applying permutations or some isotopies to them in order to get the rest that one need to test (perhaps the isotopies can depend on the context, i.e. what is being tested.). My code can generate every abelian group with fixed identity up to order \( 10 \) pretty quickly, that might be useful.

    Secondly, optimizing the code directly:

    Generating the \( 6 \times 6 \) latin squares doesn't finish on my computer due to insufficient RAM. So trying to optimize the code so that it uses less memory may be important. A known result is that every quasigroup is isotopic to a loop (with fixed identity, and without swapping labels). So therefore, one could generate every loop and then afterwards apply every isotopy to every loop in order to get every possible quasigroup. In this way, the code might not run faster, but the memory load could probably be reduced.

    The code could maybe also be multi threaded. Currently the code is only single-threaded.

    The recursive generation of the latin squares could be changed to a iterative version, maybe that would save on memory.

    There are also most likely other smarter and more efficient algorithms for generating the necessary latin squares. If one checks for associativity, maybe one could look at it like a property of a 3D group operation table. Maybe there is some symmetry on this 3D group operation table that implies associativity that would be faster to check?

    Applying optimizations should come second to reducing the amount of latin squares that need to be generated, since the amount of latin squares explodes extremely quickly as the size increases. And although the amount of abelian groups also explodes, it does so much slower, and is therefore way more bearable to compute. Even without siginificant optimizations, my code can generate every \( 10 \times 10 \) abelian group latin square fairly quickly.
\end{idea}

\subsection{Crazy ideas}

\begin{idea}
    One of my more crazy ideas is to try and use the Eckmann-Hilton argument to show when a permutation is an automorphism, since from \autoref{thm:quasi-automorphism-iff-self-conjugate} would imply that \( *_Q \) and \( *_{\phi(\tilde{Q})} \) are equal if and only if \( \phi \in \Aut(Q) \). 
    
    However, Eckmann-Hilton would imply that \( *_Q \) and \( *_{\tilde{Q}} \) are both associative and commutative, which would mean they're abelian groups from our structure. This most likely makes this idea not possible in the general case, but might be possible to apply in some special cases where we know there is some \( \tilde{Q} \) where the permutation is in \( \Aut(\tilde{Q}) \) or maybe \( \AAut(\tilde{Q}) \).
\end{idea}

\begin{idea}
    Another crazy idea relates to the attacks. Could it be possible to use the compuonding knowledge gained from asking for different values of \( \phi(x_i) \). Let \( \tilde{Q} \) be the commutative quasigroup gained from \autoref{corollary:construction-symmetric}. Then it has binary operation \( a *_{\tilde{Q}} b = \phi(a) *_Q \phi(b) \). If one for example has asked for \( k \) different values og \( \phi^{-1}(x_i) \), then one could calculate \( k \) choose 2 different sums \( x_i *_{\tilde{Q}} x_j \), which is \( k(k - 1) \in o(k^2) \). Could one use this compounding knowledge to help with gaining enough useful information for an attack fast enough?
\end{idea}

\begin{idea}
    Is it possible to use information theory code generating algorithms to make latin squares? If latin squares can make MDS-codes, then could one go the other way using Reed-Solomon codes?
\end{idea}

\subsection{Observations}

\begin{idea}
    It seems like given two abelian groups \( H, G \in \Ab(n) \), then \( \Aut(H) \cap \Aut(G) \) is either \( \Aut(H), \Aut(G) \) or \( \set{\Id} \). However, I've yet to prove this.
\end{idea}

\begin{idea}
    Experiments imply that for two abelian groups \( H, G \in \Ab(n) \) where \( H \simeq G \), then \( \AAut(H) \neq \AAut(G) \). In the ``complete\_5.ods'' file, \( s_{44915} \) and \( s_{85427} \) do not have the same affine automorphisms. However, it is known that there is only one ismorphism class for abelian groups of order \( 5 \), so they must be isomorphic.

    However, I've yet to prove the above statement algebraically. Might be usefull for context, verification and further ideas.
\end{idea}

\begin{idea} \label{idea:fingerprints}
    I have looked into something that we called the ``automorphism fingerprint'' of different quasigroups. For a given \( Q \in \Quas(n) \), then this is \( \Aut(Q) \). Every generated table that I've made is sorted with regards to this ``fingerprint''. Have looked a bit into the relation between elements with the same automorphism fingerprint, but didn't find or test anything concrete for higher \( n \) than 3. For \( n = 3 \) it seems like quasigroups with the same fingerprint are related by a single flip of either row or colum or the transpose of each other, but not always.

    I did not have time to look into the ``affine automorphism fingerprint'' of different quasigroups. They're arguably more important, since that is what the main conjecture and construction revolves around. If one can manage to find a correlation between elements with the same fingerprint, then it might be possible to only generate the latin squares that have different fingerprints, which could help a lot with \autoref{idea:code-improvements}. Maybe it could also show a way to create a new construction and help with \autoref{idea:improved-construction}.
\end{idea}

\begin{idea}
    I found no significant results or observations when working with \( n \) a prime, a composite number, or a power of a prime (i.e. a vector space), except for that every group was abelian when \( n \) was prime. Shouldn't there be some additional structure found that are lost between the different cases? Could one exploit the structure for certain \( n \) in for example \autoref{idea:code-improvements}?
\end{idea}

\subsection{Future experiments}

There are some experiments that I've yet to run, but that seems interesting.

\begin{idea}
    Firstly, want to verify the first conjecture in \autoref{idea:improved-construction} by checking for every permutation if there is a loop where it's in the \( \AAut \) of that loop. Maybe in the spreadsheet, one could add an additional row above the permutation where the best structure that permutation is \( \AAut \) in is shown.
\end{idea}

\begin{idea}
    Secondly, want to improve the bounds that have been mentioned in the second conjecture in \autoref{idea:improved-construction}. For \( n = 2^k \), does the conjecture hold? For which \( \phi \in \Sym(n) \) does the conjecture hold? Does it hold for any weaker statements? And so on.
\end{idea}

\subsection{Maybe irrelevant stuff}

\begin{idea}
    One result that I tried proving, but gave up halfway was the following:

    For \( n \geq 3 \) for every \( G \in \Ab(n) \), then \( \Aut(G) \neq \set{\Id} \). 
    
    It seems very close to be true, but I didn't manage to show that and gave up, because it seemed irrelevant for what I was trying to accomplish.
    % TODO: write the half-finished proof?
\end{idea}