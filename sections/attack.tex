I work with this security scheme: There is a Challenger that chooses a random permutation \( \phi \in \Sym(n) \). Then the Adversary can ask for a ``reasonable'' amount of \( \phi(x_i) \) for some given \( x_i \). Then afterwards, the adversary can ask for a ``reasonable'' amount of \( \phi^{-1}(y_i) \) for some given \( y_i \). In the end, the Adversary sends a tuple \( \tuple{c, \tilde{c}} \). The adversary wins if \( c \neq x_i \forall i \) and \( \tilde{c} \neq y_i \forall i \) and \( \tilde{c} = \phi(c) \). 

The idea is that given a \( \phi \in \Sym(n) \) using \autoref{construction:affine-automorphism-quasigroup}, with either \autoref{remark:construction-right-id} or \autoref{corollary:construction-symmetric} to construct a quasigroup \( \tilde{Q} \), where \( \phi \in \AAut(\tilde{Q}) \). Given the current construction, it is not possible to do better due to \autoref{remark:left-identity-killed}, so that's what we're working with.

Then using knowledge of the \( Q \in \Quas(n) \) that is used in the construction along with symmetry or right identity, it might be possible to get knowledge of the binary operation table of \( \tilde{Q} \), since that might be used in an attack. However, it turns out that the construction always gives us a known value of \( v \) in \( \phi(x) = v +_{\tilde{Q}} x \), but that doesnt help out, because the only useful values in the binary operation table of \( \tilde{Q} \) turns out to be those on row \( v \), since those ``model'' the behaviour of \( \phi(x) \) that we're looking for.

If one chooses the construction such that \( \tilde{Q} \) has \( 0 \) as a right identity (choose \( Q \) to be a commutative loop with identity \( 0 \)). Then one immediately knows that there is a column in the binary operation table that is equal to \( \tuple{0, 1, \dots, n - 1} \). However, one only knows the column number by asking for \( \phi^{-1}(0) \), which is the only useful knowldge one could have gained from the colum, which ruins the purpose.

If one choses the construction such that \( \tilde{Q} \) is commutative, then for every value one checks in the binary operation table of \( \tilde{Q} \), one gets two rows and two columns worth of latin square knowledge due to the symmetric binary operation table since it's commutative (if it's not on the diagonal). However, one still has to check at least \( \frac{n}{2} \) different values in the table to conclude a single non-checked value of the ``important'' \( \phi^{-1}(e) \) row, which is still too much.

If one choses the construction such that \( \tilde{Q} \) is commutative and \( Q \) is the XOR abelian group table, one gets that the diagonal on the binary operation table of \( \tilde{Q} \) is all zeros. However, again this is all useless since \( v = \phi^{-1}(0) \), so one has already asked for the only useful information one would have gained.

I started to continue building on the idea of using a commutative construction from XOR, and trying to use the basis that XOR has as a vector space over \( \mathbb{Z}_2 \), but I didn't manage to find out anything, and it all seemed to be a dead end, since \( \tilde{Q} \) is not associative, which makes it very hard to work with.